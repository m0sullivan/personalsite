import {
  toWritable,
  unstore
} from "./chunk-LRJQKUWD.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-KLNSLHAC.js";

// src/dicts/contains/index.ts
function contains(obj, ...keys) {
  return keys.some((key) => key in obj);
}

// src/dicts/invert/index.ts
function invert(obj) {
  if (!obj)
    return {};
  return Object.keys(obj).reduce(
    (acc, key) => __spreadProps(__spreadValues({}, acc), {
      [obj[key]]: key
    }),
    {}
  );
}

// src/dicts/enhance/index.ts
function enhance(obj) {
  const dict = toWritable(obj);
  function add(key, value) {
    dict.update((n) => {
      n[key] = value;
      return n;
    });
  }
  function clear() {
    dict.update((n) => {
      for (const key in n) {
        delete n[key];
      }
      return n;
    });
  }
  function contains2(key) {
    return contains(unstore(dict), key);
  }
  function copy() {
    return enhance(__spreadValues({}, unstore(dict)));
  }
  function fromKeys(keys2, value) {
    return enhance(
      keys2.reduce((n, k) => {
        n[k] = value;
        return n;
      }, {})
    );
  }
  function get(key, fallback = null) {
    var _a;
    return (_a = unstore(dict)[key]) != null ? _a : fallback;
  }
  function invert2() {
    dict.set(invert(unstore(dict)));
  }
  function keys() {
    return Object.keys(unstore(dict));
  }
  function pop(key) {
    const value = get(key);
    dict.update((n) => {
      delete n[key];
      return n;
    });
    return value;
  }
  function popitem() {
    const key = Object.keys(unstore(dict)).pop();
    if (key) {
      const value = get(key);
      dict.update((n) => {
        delete n[key];
        return n;
      });
      return [key, value];
    }
    return null;
  }
  function values() {
    return Object.values(unstore(dict));
  }
  return {
    subscribe: dict.subscribe,
    add,
    clear,
    contains: contains2,
    copy,
    fromKeys,
    get,
    invert: invert2,
    keys,
    pop,
    popitem,
    values
  };
}

// src/dicts/filter/index.ts
function filter(obj, filter2 = (x) => !x) {
  if (!obj)
    return {};
  return Object.keys(obj).reduce((acc, key) => {
    if (filter2(obj[key])) {
      return acc;
    } else
      return __spreadProps(__spreadValues({}, acc), { [key]: obj[key] });
  }, {});
}

// src/dicts/listify/index.ts
function listify(obj, toItem) {
  if (!obj)
    return [];
  const entries = Object.entries(obj);
  if (entries.length === 0)
    return [];
  return entries.reduce((acc, entry) => {
    return [...acc, toItem(entry[0], entry[1])];
  }, []);
}

// src/dicts/picker/index.ts
function picker(obj, keys, omitUndefined = false) {
  return keys.reduce((n, k) => {
    if (k in obj) {
      if (!omitUndefined || obj[k] !== void 0)
        n[k] = obj[k];
    }
    return n;
  }, {});
}

// src/dicts/pops/index.ts
function pops(obj, keys) {
  for (const key of keys) {
    delete obj[key];
  }
}
export {
  contains,
  enhance,
  filter,
  invert,
  listify,
  picker,
  pops
};
