import * as svelte_store from 'svelte/store';
import { Readable, Writable } from 'svelte/store';
import { A as AnyFn, E as EventFilter, a as ArgumentsType, D as DebounceFilterOptions, P as Pauseable, M as MaybeStore, F as Fn, b as AsyncStateOptions, c as EventHook, d as FunctionArgs, e as PromisifyFn, I as IntervalFnOptions, W as Watchable, R as RTFOptions, S as SlugOptions, f as DateLike, g as StrftimeOptions, T as ToggleFn, h as DefaultTaggableReturn, i as TimeoutFnOptions, j as ToNumberOptions } from './types-8a2f2352.js';
export { n as Awaitable, G as ClusterOptions, C as ConfigurableEventFilter, K as CycleOptions, p as Dict, m as ElementOf, J as EnhanceSortOptions, u as EventHookOff, t as EventHookOn, v as EventHookTrigger, s as FunctionWrapperOptions, H as IntersectsOptions, L as ListAble, k as MaybeReadable, l as MaybeWritable, o as Mutable, r as PartialWritable, B as PrecisionOptions, z as Sequential, w as SingletonPromiseReturn, q as Stoppable, y as StringOrNumber, x as TimeoutOptions } from './types-8a2f2352.js';

/**
 * Create a wrapper function that will apply the filter to the function
 *
 * @internal
 *
 * @param filter - The filter to be applied
 *
 * @param fn - The function to be wrapped
 *
 *  @returns A wrapped function
 */
declare function createFilterWrapper<T extends AnyFn>(filter: EventFilter, fn: T): (this: any, ...args: ArgumentsType<T>) => Promise<ReturnType<T>>;
/**
 * A filter that bypasses all events
 *
 * @param invoke - The function to be invoked
 *
 * @returns The result of the function
 */
declare const bypassFilter: EventFilter;
/**
 * Create an EventFilter that debounce the events
 *
 * @param s - The time to wait before invoking the function in seconds
 *
 * @param options - The options for the filter
 * - `maxWait` - The maximum time allowed to be delayed before it's invoked. In seconds.
 * - `rejectOnCancel` - Whether to reject the last call if it's been cancel. Default to `false`
 *
 * @returns The event filter function
 */
declare function debounceFilter(s: number, options?: DebounceFilterOptions): EventFilter;
/**
 * Create an EventFilter that throttle the events
 *
 * @param s - The time to wait before invoking the function in seconds
 *
 * @param trailing - Whether to invoke the function on the trailing edge of the wait interval
 *
 * @param leading - Whether to invoke the function on the leading edge of the wait interval
 *
 * @param rejectOnCancel - Whether to reject the promise when the event is cancelled
 */
declare function throttleFilter(s: number, trailing?: boolean, leading?: boolean, rejectOnCancel?: boolean): EventFilter;
/**
 * EventFilter that gives extra controls to pause and resume the filter
 *
 * @param extendFilter - Extra filter to apply when the PauseableFilter is active, default to none
 *
 * @returns
 * - `active` - A readable store that indicates whether the filter is active
 * - `pause` - A function to pause the filter
 * - `resume` - A function to resume the filter
 * - `eventFilter` - The event filter function
 *
 */
declare function pauseableFilter(extendFilter?: EventFilter): Pauseable & {
    eventFilter: EventFilter;
};

declare const browser: boolean;
declare const isWs: boolean;
/**
 * Check if the value is a function
 *
 * @param value - The value to check
 *
 * @returns Whether the value is a function or not
 */
declare function isFunction<T>(value?: T): boolean;
/**
 * Check if the value is readable store, if return the subscribe function
 *
 * @param value - The value to check
 *
 * @returns Whether the value is readable store or not
 */
declare function isReadable<T>(value: any): value is Readable<T>;
/**
 * Check if the value is writable store, if return the set, update and subscribe function
 *
 * @param value - The value to check
 *
 * @returns Whether the value is writable store or not
 */
declare function isWritable<T>(value: any): value is Writable<T>;
/**
 * Check if the value is partial writable store, if return the set and subscribe function
 *
 * @param value - The value to check
 *
 * @returns Whether the value is partial writable store or not
 *
 */
declare function isPartialWritable<T>(value: any): value is Writable<T>;
/**
 * Check if the value is readable only store, that only return the subscribe function without set and update
 *
 * @param value - The value to check
 *
 * @returns Whether the value is readable only store or not
 */
declare function isReadableOnly<T>(value: any): value is Readable<T>;
/**
 * Check if the value is svelte store.
 *
 * @param value - The value to check
 *
 * @returns Whether the value is svelte store or not
 */
declare function isStore<T>(value: any): value is MaybeStore<T>;
/**
 * Check if the value is empty
 *
 * @param value - The value to check
 *
 * @returns Whether the value is empty or not
 *
 */
declare function isEmpty(value: unknown): boolean;
/**
 * check if the two values are equal
 *
 * @param x - The first value to check
 *
 * @param y - The second value to check
 *
 * @returns Whether the two values are equal or not
 */
declare function isEqual<T, U>(x: T, y: U): boolean;
declare const noop: () => void;

/**
 * A function that get date type, that inspired from python type function.
 *
 * @remarks This function is used to get the type of the value.
 *
 * @param value - The value to get type.
 *
 * @param full - Whether to return the full type or not.
 *
 * @example
 * ```ts
 * type(1) // number
 * type(1, true) // [object Number]
 * ```
 *
 * @see https://docs.python.org/3/library/functions.html#type
 *
 * @returns The type of the value.
 */
declare function type<T>(value: T, full?: boolean): string;
/**
 * Safely get the value of a store, or return the value if it's not a store.
 *
 * @param value - The value to unstore.
 *
 * @example
 * ```ts
 * unstore(1) // 1
 * unstore(readable(1)) // 1
 * unstore(writable(1)) // 1
 * ```
 * @returns The value of the store, or the value if it's not a store.
 */
declare function unstore<T>(value: MaybeStore<T>): T;
/**
 * Convert a value or a store to a writable store.
 *
 * @param value - The value or store to convert.
 *
 * @example
 * ```ts
 * toWritable(1) // writable(1)
 * toWritable(readable(1)) // writable(1)
 * toWritable(writable(1)) // writable(1)
 * ```
 * @returns A writable store.
 */
declare function toWritable<T>(value: MaybeStore<T>): Writable<T>;
/**
 * A function that converts a value to a readable store, the value could be plain, writable, or even readable store
 *
 * @param value - the value to be converted
 *
 * @example
 * ```ts
 * toReadable(1) // readable(1)
 * toReadable(readable(1)) // readable(1)
 * toReadable(writable(1)) // readable(1)
 * ```
 * @returns a readable store
 */
declare function toReadable<T>(value: MaybeStore<T>): Readable<T>;
/**
 * Create singleton promise function
 *
 * @param fn - function to be wrapped
 *
 * @example
 * ```
 * const promise = createSingletonPromise(async () => { ... })
 *
 * await promise()
 * await promise() // all of them will be bind to a single promise instance
 * await promise() // and be resolved together
 * ```
 *
 * @returns singleton promise function
 */
declare function createSingletonPromise<T>(fn: () => Promise<T>): {
    (): Promise<T>;
    reset(): Promise<void>;
};
/**
 * Call onDestroy() if it's inside a component lifecycle, if not, do nothing.
 *
 * @param fn - the function to be called when the component is destroyed
 *
 * @returns true if onDestroy() is called, false if not
 */
declare function on_destroy(fn: Fn): boolean;

/**
 * Adjust a value with unit
 *
 * @param target - Target value
 *
 * @param delta - Delta value
 *
 * @example
 * ```ts
 * const count = adjustWithUnit("1px", 1)
 * count.inc() // "2px"
 * count.dec() // "1px"
 * ```
 *
 * @returns A store with `inc` and `dec` methods
 */
declare function adjustWithUnit(target: MaybeStore<string | number>, delta: number): {
    subscribe: (this: void, run: svelte_store.Subscriber<string | number>, invalidate?: svelte_store.Invalidator<string | number> | undefined) => svelte_store.Unsubscriber;
    inc: () => void;
    dec: () => void;
};

/**
 * A function that executes a promise and returns a state.
 *
 * @param promise - The promise to execute.
 *
 * @param initialState - The initial state of the state.
 *
 * @param options - The options.
 * - `delay` - Delay for executing the promise. In second.
 * - `immediate` - Execute the promise right after the function is invoked.
 * - `on_error` - Callback when error is caught.
 * - `resetOnExecute` - Sets the state to initial state before executing the promise.
 * - `throwError` - An error is thrown when executing the execute function.
 *
 * @example
 * ```ts
 * const { state, ready, loading, error, execute } = asyncState(
 * 	() => Promise.resolve(1),
 * 	0,
 * 	{ immediate: false }
 * )
 * ```
 *
 * @returns An object with the following properties:
 * - `state` - The state.
 * - `ready` - A boolean that indicates if the promise has been resolved.
 * - `loading` - A boolean that indicates if the promise is being executed.
 * - `error` - The error that was caught.
 * - `execute` - A function that executes the promise manually.
 */
declare function asyncState<T, Params extends any[] = []>(promise: Promise<T> | ((...args: Params) => Promise<T>), initialState: T, options?: AsyncStateOptions): {
    state: svelte_store.Readable<T>;
    ready: svelte_store.Readable<boolean>;
    loading: svelte_store.Readable<boolean>;
    error: svelte_store.Readable<unknown>;
    execute: (delay?: number, ...args: any[]) => Promise<T>;
};

/**
 * Utility for creating event hooks
 *
 *
 * @example
 * ```ts
 * const { on, off, trigger } = createEventHook<string>()
 *
 * on((param) => console.log(param))
 *
 * trigger("xxx") // xxx
 *
 * off((param) => console.log(param))
 *
 * trigger("xxx") // nothing
 *```
 *
 * @returns - Event hooks
 * - `on` - Add a function to the event hook
 * - `off` - Remove a function from the event hook
 * - `trigger` - Trigger the event hook
 */
declare function createEventHook<T = any>(): EventHook<T>;

/**
 * Debounce execution of a function.
 *
 * @param fn - A function to be executed after delay seconds debounced.
 *
 * @param s - The time to wait before invoking the function in seconds.
 *
 * @param options - Options to pass to the debounce filter.
 * - `maxWait` - The maximum time allowed to be delayed before it's invoked. In seconds.
 * - `rejectOnCancel` - Whether to reject the last call if it's been cancel. Default `false`.
 *
 * @example
 * ```ts
 * let counter = 0
 *
 * const fn = debounce(() => {
 * 	counter++
 * }, 1)
 *
 * fn()
 *
 * fn()
 *
 * await sleep(1)
 *
 * console.log(counter) // 1
 * ```
 *
 * @returns A new debounce function.
 */
declare function debounce<T extends FunctionArgs>(fn: T, s?: number, options?: DebounceFilterOptions): PromisifyFn<T>;

/**
 * Wrapper for `setInterval` with controls
 *
 * @param fn - callback function
 *
 * @param interval - interval in seconds
 *
 * @example
 * ```ts
 * const { pause, resume } = intervalFn(() => { ... }, 1)
 *
 * pause() // pause the interval
 *
 * resume() // resume the interval
 *
 * ```
 *
 * @returns Pauseable object
 * - `active` - store indicating whether the interval is active
 * - `pause` - pause function to pause the interval
 * - `resume` - resume function to resume the interval
 *
 */
declare function intervalFn(fn: Fn, interval?: MaybeStore<number>, options?: IntervalFnOptions): Pauseable;

/**
 * A function that tracks changes to value and update a timestamp.
 *
 * @param initialValue - The initial value of the store.
 *
 * @param initialTimestamp- An optional initial timestamp.
 *
 * @example
 * ```ts
 * const { value, timestamp } = lastChanged(0)
 *
 * value.set(1)
 *
 * console.log($timestamp) // 1626948980000
 *
 * value.set(2)
 *
 * console.log($timestamp) // 1626948981000
 * ```
 *
 * @returns An object containing the store and the timestamp store.
 */
declare function lastChanged<T>(initialValue: MaybeStore<T>, initialTimestamp?: number): {
    value: Watchable<T>;
    timestamp: svelte_store.Readable<number>;
};

/**
 * A function that returns the length of an item.
 *
 * @param item - The item to get the length of.
 *
 * @see https://docs.python.org/3/library/functions.html#len
 *
 * @example
 * ```ts
 * len([1, 2, 3]) // 3
 *
 * len("hello") // 5
 *
 * len({ a: 1, b: 2 }) // 2
 *
 * len(new Set([1, 2, 3])) // 3
 *
 * len(new Map([["a", 1], ["b", 2]])) // 2
 *
 * len(1) // TypeError: len() argument must be a sequence or collection, not number
 *
 * len(null) // TypeError: len() argument must be a sequence or collection, not null
 * ```
 * @returns The length of the item.
 */
declare function len<T>(item: T): number;

/**
 * Make isomorphic destructurable for object and array at the same time
 *
 * @param obj - The object to make destructurable.
 *
 * @param arr - The array to use for destructuring.
 *
 * @see https://antfu.me/posts/destructuring-with-object-or-array
 *
 * @example
 * ```ts
 * const foo = { name: "foo" }
 *
 * const bar = 1024
 *
 * const obj = makeDestructurable(
 * 	{ foo, bar } as const,
 * 	[foo, bar] as const
 * )
 *
 * const { foo: foo2, bar: bar2 } = obj
 *
 * const [foo3, bar3] = obj
 * ```
 *
 * @returns The destructurable object.
 */
declare function makeDestructurable<T extends Record<string, unknown>, A extends readonly any[]>(obj: T, arr: A): T & A;

/**
 * URL representing an object.
 *
 * @param value - The value to create an object URL for.
 *
 * @returns The object URL.
 */
declare function objectUrl(value: MaybeStore<Blob | MediaSource | undefined>): string;

/**
 * Returns an generator of numbers from start to stop.
 *
 * @param start - The start of the range.
 *
 * @param stop - The end of the range.
 *
 * @param step - The step of the range.
 *
 * @see https://docs.python.org/3/library/functions.html#func-range
 *
 * @example
 * ```ts
 * range(1, 5) // [1, 2, 3, 4, 5]
 * range(1, 5, 2) // [1, 3, 5]
 * range(5, 1, -1) // [5, 4, 3, 2, 1]
 * range(10) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10]
 * ```
 *
 * @returns An generator of numbers.
 */
declare function range(start: number, stop?: number, step?: number): Generator<number>;

/**
 * Get the relative time string from a date.
 *
 * @param date - The date to format.
 *
 * @param options - The options to use.
 * - `locale` - The locale to use.
 * - `style` - The length of the internationalized message.
 * - `numeric` - The format of output message.
 * - `interval` - The interval to update the time. Defaults to 60 seconds.
 *
 * @example
 * ```ts
 * rtf(new Date()) // "in 1 minute"
 *
 * rtf(new Date(Date.now() - 1000 * 60 * 60 * 24)) // "1 day ago"
 *
 * rtf(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365), {
 * 	locale: "ar",
 * }) // "بعد سنة"
 * ```
 *
 * @returns The relative time string.
 */
declare function rtf(date: Date | number, options?: RTFOptions): Readable<string>;

/**
 * A function that returns a promise that resolves after a given amount of time.
 *
 * @param s - The amount of time to wait in seconds.
 *
 * @param throwOnTimeout - Whether to throw an error after the timeout.
 *
 * @param reason - The reason to throw if `throwOnTimeout` is `true`.
 *
 * @see https://docs.python.org/3/library/time.html#time.sleep
 *
 * @example
 * ```ts
 * await sleep(1) // Wait for 1 second
 * await sleep(1, true, "Timeout") // Throw an error after 1 second
 * ```
 *
 * @returns A promise that resolves after `s` seconds.
 */
declare function sleep(s: number, throwOnTimeout?: boolean, reason?: string): Promise<void>;

/**
 * Returns a random slug.
 *
 * @param options - The options.
 * - `lower` - Whether to include lowercase letters. Defaults to `true`.
 * - `upper` - Whether to include uppercase letters. Defaults to `true`.
 * - `digits` - Whether to include digits. Defaults to `true`.
 * - `size` - The size of the slug. Defaults to `6`.
 * - `prefix` - The prefix to use.
 *
 * @example
 * ```ts
 * slug() // "BcDeF1"
 * slug({ lower: false }) // "E1F2G3"
 * slug({ upper: false }) // "a1b2c3"
 * slug({ digits: false }) // "aBcDeF"
 * slug({ size: 10 }) // "aBcDeFgHiJ"
 * slug({ prefix: "test" }) // "test-aBcDeF"
 * ```
 *
 * @returns A random slug.
 */
declare function slug(options?: SlugOptions): string;

/**
 * Formats a date for a given format string code
 *
 * @param date - The date to format
 *
 * @param str - The format string code
 *
 * @param options - The options to pass to the date formatter
 * - locales - The locales to use for formatting
 *  - DateTimeFormatOptions - The options to pass to the date formatter.
 *
 * @see https://docs.python.org/3/library/datetime.html#datetime.date.strftime
 *
 * @see  Format Codes: https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
 *
 * @example
 * ```ts
 * strftime(new Date(), "%Y-%m-%d") // 2021-01-01
 *
 * strftime(new Date(), "%Y-%m-%d", { locales: "en-US" }) // 2021-01-01
 *
 * strftime(new Date(), "%Y-%m-%d", { locales: "ar-EG" }) // ٢٠٢١-٠١-٠١
 * ```
 *
 * @returns The formatted date string.
 */
declare function strftime(date: DateLike, str: string, options?: StrftimeOptions): string;

/**
 * Creates a taggable store.
 *
 * @param value - initial state.
 *
 * @defaultValue false
 *
 * @returns
 * - `toggle` - a function to toggle the state.
 * - `toggled` - a readable store with the current state. if the value is not writable store
 */
declare function taggable(value: Writable<boolean>): ToggleFn;
declare function taggable(value?: MaybeStore<boolean>): DefaultTaggableReturn;

/**
 * Replaces a search expression with values from a data object
 *
 * @param str - The string to be searched
 *
 * @param data - The data object to be used to replace the search expression
 *
 * @param regex - The search expression
 *
 * @example
 * ```ts
 * template("Hello {{name}}", { name: "John" }) // "Hello John"
 *
 * template("Hello {name}", { name: "John" }, /{(.+?)}/g) // "Hello John"
 * ```
 * @returns A string with values from data object using search expression
 */
declare function template(str: string, data: Record<string, any>, regex?: RegExp): string;

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param fn - A function to be executed after delay seconds debounced.
 *
 * @param s - The time to wait before invoking the function in seconds
 *
 * @param trailing - If true, call fn again after the time is up
 *
 * @param leading - if true, call fn on the leading edge of the s timeout
 *
 * @param rejectOnCancel - Whether to reject the promise if the function is cancelled.
 *
 * @example
 * ```ts
 * const fn = throttle(() => console.log("Hello World"), 1)
 *
 * fn() // "Hello World"
 *
 * fn() // Nothing
 *
 * await sleep(1)
 *
 * fn() // "Hello World"
 *
 * fn()	// Nothing
 * ```
 *
 * @returns A new throttled function.
 */
declare function throttle<T extends FunctionArgs>(fn: T, s?: number, trailing?: boolean, leading?: boolean, rejectOnCancel?: boolean): PromisifyFn<T>;

/**
 * Wrapper for `setTimeout` with controls.
 *
 * @param fn - callback function

 * @param interval - interval in seconds
 *
 * @param options - options
 * - `immediate` - start the timer immediate after calling this function
 * - `immediateCallback` - execute the callback immediate after calling this function
 *
 * @example
 * ```ts
 * const { active, pause, resume } = timeoutFn(() => { ... }, 1)
 *
 * $active // store indicating whether the timer is active
 *
 * pause() // pause the timer
 *
 * resume() // resume the timer
 * ```
 * @returns Pauseable object
 * - `active` - store indicating whether the timer is active
 * - `pause` - pause function to pause the timer
 * - `resume` - resume function to resume the timer
 */
declare function timeoutFn(fn: Fn, interval?: MaybeStore<number>, options?: TimeoutFnOptions): Pauseable;

/**
 * Convert a value to a number.
 *
 * @param value - The value to convert to a number.
 *
 * @param options - Options to control the conversion.
 * - `method` - The method to use to convert the value. Default `float`.
 * - `radix` - The base in mathematical numeral systems passed to `int`. Only works with `method: 'int'`
 * - `nanToZero` - Replace NaN with zero. Default `false`.
 *
 * @example
 * ```ts
 * toNumber("123.345") // 123.345
 * toNumber("123.345", { method: "int" }) // 123
 * toNumber("0xFA", { method: "int", radix: 16 }) // 250
 * toNumber("Hello", {nanToZero: true }) // 0
 * ```
 *
 * @returns The converted number.
 */
declare function toNumber(value: number | string, options?: ToNumberOptions): number;

/**
 * Convert a function to an error-first async function.
 *
 * @param fn - A function to be converted to an error-first async function.
 *
 * @see https://radash-docs.vercel.app/docs/async/tryit
 *
 * @example
 * ```ts
 * const { result, error } = await atryit(async () => {
 * 	return "hello"
 * })()
 * ```
 *
 * @returns An error-first async function.
 *
 */
declare function atryit(fn: AnyFn): (...args: any) => Promise<{
    result: any;
    error: null;
} | {
    result: null;
    error: unknown;
}>;
/**
 * Convert a function to an error-first function.
 *
 * @param fn - A function to be converted to an error-first function.
 *
 * @example
 * ```ts
 * const { result, error } = tryit(() => {
 * 	return "hello"
 * })()
 * ```
 *
 * @returns An error-first function.
 */
declare function tryit(fn: AnyFn): (...args: any) => {
    result: any;
    error: null;
} | {
    result: null;
    error: unknown;
};

/**
 * Creates a watchable store that calls a function when the value changes.
 *
 * @param initialValue - Initial value to start watching
 *
 * @param fn - Function to call when the value changes
 *
 * @see https://vuejs.org/guide/essentials/watchers.html
 *
 * @example
 * ```ts
 * const count = watchable(0, (o, n) => {
 * 	console.log(`count changed from ${o} to ${n}`)
 * })
 * ```
 *
 * @returns A writable store that calls a function when the value changes
 */
declare function watchable<T>(initialValue: MaybeStore<T>, fn: (o: T, n: T) => void): Watchable<T>;

export { AnyFn, ArgumentsType, AsyncStateOptions, DateLike, DebounceFilterOptions, DefaultTaggableReturn, EventFilter, EventHook, Fn, FunctionArgs, IntervalFnOptions, MaybeStore, Pauseable, PromisifyFn, RTFOptions, SlugOptions, StrftimeOptions, TimeoutFnOptions, ToNumberOptions, ToggleFn, Watchable, adjustWithUnit, asyncState, atryit, browser, bypassFilter, createEventHook, createFilterWrapper, createSingletonPromise, debounce, debounceFilter, intervalFn, isEmpty, isEqual, isFunction, isPartialWritable, isReadable, isReadableOnly, isStore, isWritable, isWs, lastChanged, len, makeDestructurable, noop, objectUrl, on_destroy, pauseableFilter, range, rtf, sleep, slug, strftime, taggable, template, throttle, throttleFilter, timeoutFn, toNumber, toReadable, toWritable, tryit, type, unstore, watchable };
