import { G as ClusterOptions, M as MaybeStore, K as CycleOptions, J as EnhanceSortOptions, H as IntersectsOptions, p as Dict } from './types-8a2f2352.js';
import * as svelte_store from 'svelte/store';

/**
 * Split a list into sublists.
 *
 * @param list - The list to split.
 *
 * @param options - The options to use.
 * - `size` - The max size of each sublist. Default: `2`
 *
 * @example
 * ```ts
 * cluster([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) // [
 * 	// [1, 2]
 * 	// [3, 4]
 * 	// [5, 6]
 * 	// [7, 8]
 * 	// [9, 10]
 * // ]
 *
 * cluster([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], { size: 3 }) // [
 * 	// [1, 2, 3]
 * 	// [4, 5, 6]
 * 	// [7, 8, 9]
 * 	// [10]
 * // ]
 * ```
 *
 * @returns List of sublists.
 */
declare function cluster<T>(list: T[], options?: ClusterOptions): T[][];

/**
 * Counts the number of times each item appears in a list.
 *
 * @param list -  The list to count.
 *
 * @param fn -  A function that returns the id of an item or the field to count.
 *
 * @example
 * ```ts
 * count([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], (n) => n % 2 === 0 ? "even" : "odd") // { even: 5, odd: 5 }
 * ```
 *
 * @returns A record of the number of times each item appears in the list.
 */
declare function count<T>(list: T[], fn: (item: T) => string | number | symbol): Record<string | number | symbol, number>;

/**
 * Cycle through a list of items
 *
 * @param list - The list to cycle through
 *
 * @param options - The options for the cycle
 * - `fallback` - The initial value of the state.
 * - `fallback_index` - The default index when
 * - `getIndex` - Custom function to get the index of the current value.
 *
 * @example
 * ```ts
 * const { state, next, prev } = cycle(["a", "b", "c"])
 * next() // "b"
 * next() // "c"
 * next() // "a"
 * prev() // "c"
 * ```
 *
 * @returns The state and the index
 * - `state` - The current value
 * - `index` - The current index
 * - `next` - Go to the next item in the list
 * - `prev` - Go to the previous item in the list
 *
 */
declare function cycle<T>(list: MaybeStore<T[]>, options?: CycleOptions<T>): {
    state: svelte_store.Readable<T>;
    index: svelte_store.Readable<number>;
    next: (n?: number) => number;
    prev: (n?: number) => number;
};

/**
 * Enhance an array with some useful methods.
 *
 * @param arr - The array to enhance.
 *
 * @example
 * ```ts
 * const list = enhance([1, 2, 3])
 * list.subscribe((value) => console.log(value))
 * list.append(4)
 * list.clear()
 * list.count(1)
 * list.copy()
 * list.index(1)
 * list.insert(1, 2)
 * list.remove(1)
 * list.pop()
 * ```
 *
 * @returns The enhanced array.
 * - `subscribe` - A svelte store.
 * - `append` - Add an item to the end of the list.
 * - `clear` - Remove all items from the list.
 * - `count` - Count the number of times an item appears in the list.
 * - `copy` - Returns a copy of the list.
 * - `index` - Returns the index of the first item that matches the given value.
 * - `insert` - Insert an item at a given position.
 * - `remove` - Removes an item from the list.
 * - `pop` - Remove an item by index.
 * - `sort` - Sort the list.
 */
declare function enhance<T>(arr: T[]): {
    subscribe: (this: void, run: svelte_store.Subscriber<T[]>, invalidate?: svelte_store.Invalidator<T[]> | undefined) => svelte_store.Unsubscriber;
    append: (item: T | T[]) => void;
    clear: () => void;
    count: (item?: T) => number;
    copy: () => any;
    index: (item: T, start?: number) => number;
    insert: (item: T | T[], index?: number) => void;
    remove: (item: T | T[]) => void;
    pop: (index?: number) => T | undefined;
    sort: (options?: EnhanceSortOptions) => void;
};

/**
 * Fork a list into two lists based on a condition.
 *
 * @param list - List to fork
 *
 * @param fn - Function to apply a condition to each item in the list
 *
 * @example
 * ```ts
 * fork([1, 2, 3, 4], (item) => item % 2 === 0) // [[2, 4], [1, 3]]
 * ```
 * @returns A list of lists, where the first list contains all items that match the condition, and the second list contains all items that do not match the condition
 */
declare function fork<T>(list: T[], fn: (item: T) => boolean): [T[], T[]];

/**
 * Groups a list of items by a given function.
 *
 * @param list - List to group
 *
 * @param fn - Function to group by
 *
 * @example
 * ```ts
 * group(
 * 	[{ id: 1, name: "a" }, { id: 2, name: "b" }, { id: 3, name: "a" }],
 * 	(item) => item.name
 * ) // { a: [{ id: 1, name: "a" }, { id: 3, name: "a" }], b: [{ id: 2, name: "b" }] }
 * ```
 * @returns A record of lists, where the key is the result of the function, and the value is the list of items that match the key
 */
declare function group<T>(list: T[], fn: (item: T) => any): Record<string, T[]>;

/**
 * Determine whether the given arrays intersect.
 *
 * @param a - The first array.
 *
 * @param b - The second array.
 *
 * @param options - options:
 * - `fn` - A function that returns a unique key for each item in the array.
 *
 * @example
 * ```ts
 * intersects([1, 2, 3], [2, 3, 4]) // [true, [2, 3]]
 * ```
 * @returns a boolean value indicating whether the arrays intersect and the intersecting items.
 */
declare function intersects<T, K extends string | number | symbol>(a: T[], b: T[], options?: IntersectsOptions<T, K>): [boolean, T[]];

/**
 * Merge two lists and override the first list with the second list
 *
 * @param list - The first list.
 *
 * @param other - The second list to merge.
 *
 * @param fn - A function that returns a unique key for each item in the array.
 *
 * @example
 * ```ts
 * merge(
 * 	[{ id: 1, name: "a" }, { id: 2, name: "b" }],
 * 	[{ id: 1, name: "c" }, { id: 3, name: "d" }],
 * 	(item) => item.id
 * ) // [{ id: 1, name: "c" }, { id: 2, name: "b" }, { id: 3, name: "d" }]
 * ```
 * @returns a new list with the second list merged into the first list.
 */
declare function merge<T, K extends string | number | symbol>(list: T[], other: T[], fn: (item: T) => K): T[];

/**
 * Selects a list of values from a list of objects
 *
 * @param list - The list of objects to select from
 *
 * @param fn - The function to select the value from the object
 *
 * @param condition - The condition to filter the list by
 *
 * @example
 * ```ts
 * select([{ a: 1 }, { a: 2 }, { a: 3 }], (item) => item.a) // [1, 2, 3]
 * ```
 *
 * @returns The list of values
 */
declare function select<T, K>(list: T[], fn: (item: T) => K, condition?: (item: T) => boolean): K[];

/**
 * Sorts a list of objects by a given key.
 *
 * @param list - The list to sort.
 *
 * @param key - The key to sort by.
 *
 * @example
 * ```ts
 * sort([{ a: 1 }, { a: 2 }], "a") // [{ a: 1 }, { a: 2 }]
 * sort([{ a: 1 }, { a: 2 }], "-a") // [{ a: 2 }, { a: 1 }]
 * ```
 *
 * @returns The sorted list.
 */
declare function sort<T extends Dict>(list: T[], key: string): T[];

/**
 * Gets the unique values of an array.
 *
 * @param list - The array to process.
 *
 * @param fn - The function to determine field values
 *
 * @example
 * ```ts
 * unique([1, 2, 2, 3, 4, 4, 5, 6, 6, 7], (item) => item) // [1, 2, 3, 4, 5, 6, 7]
 * ```
 *
 * @returns The new array of unique values.
 */
declare function unique<T, K extends string | number | symbol>(list: T[], fn: (item: T) => K): T[];

export { cluster, count, cycle, enhance, fork, group, intersects, merge, select, sort, unique };
