import {
  len,
  watchable
} from "./chunk-GC5LEYOY.js";
import {
  toReadable,
  toWritable,
  unstore
} from "./chunk-LRJQKUWD.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-KLNSLHAC.js";

// src/lists/cluster/index.ts
function cluster(list, options = {}) {
  const { size = 2 } = options;
  if (size === 0)
    return [];
  const cluster_count = Math.ceil(list.length / size);
  return new Array(cluster_count).fill(null).map((_c, i) => {
    return list.slice(i * size, i * size + size);
  });
}

// src/lists/count/index.ts
function count(list, fn) {
  return list.reduce((acc, item) => {
    var _a;
    const id = fn(item);
    return __spreadProps(__spreadValues({}, acc), {
      [id]: ((_a = acc[id]) != null ? _a : 0) + 1
    });
  }, {});
}

// src/lists/cycle/index.ts
function cycle(list, options) {
  function get_fallback() {
    var _a;
    return (_a = options == null ? void 0 : options.fallback) != null ? _a : unstore(list)[0];
  }
  function getIndex() {
    var _a;
    const target_list = unstore(list);
    let index2 = (options == null ? void 0 : options.getIndex) ? options.getIndex(unstore(state), target_list) : target_list.indexOf(unstore(state));
    if (index2 < 0)
      index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;
    return index2;
  }
  function set_value(_index) {
    const target_list = unstore(_list);
    const length = len(target_list);
    const index2 = (_index % length + length) % length;
    const value = target_list[index2];
    state.set(value);
    return value;
  }
  function shift(delta = 1) {
    const new_index = getIndex() + delta;
    index.set(new_index);
    return unstore(index);
  }
  function next(n = 1) {
    return shift(n);
  }
  function prev(n = 1) {
    return shift(-n);
  }
  const state = toWritable(get_fallback());
  const _list = toWritable(list);
  const index = watchable(0, (_, new_value) => {
    set_value(new_value);
  });
  return {
    state: toReadable(state),
    index: toReadable(index),
    next,
    prev
  };
}

// src/lists/sort/index.ts
function sort(list, key) {
  if (!list)
    return [];
  let sort_order = 1;
  if (key[0] === "-") {
    sort_order = -1;
    key = key.slice(1);
  }
  const order = (a, b) => {
    const result = a[key] < b[key] ? -1 : a[key] > b[key] ? 1 : 0;
    return result * sort_order;
  };
  return list.slice().sort(order);
}

// src/lists/enhance/index.ts
function enhance(arr) {
  const list = toWritable(arr);
  function append(item) {
    if (Array.isArray(item)) {
      list.update((n) => [...n, ...item]);
    } else {
      list.update((n) => [...n, item]);
    }
  }
  function clear() {
    list.set([]);
  }
  function count2(item) {
    if (item) {
      let count3 = 0;
      const _list = unstore(list);
      for (let i = 0; i < _list.length; i++) {
        if (_list[i] === item) {
          count3++;
        }
      }
      return count3;
    } else {
      return arr.length;
    }
  }
  function copy() {
    return enhance([...unstore(list)]);
  }
  function index(item, start) {
    return unstore(list).indexOf(item, start);
  }
  function insert(item, index2 = 0) {
    if (Array.isArray(item)) {
      list.update((n) => [
        ...n.slice(0, index2),
        ...item,
        ...n.slice(index2)
      ]);
    } else {
      list.update((n) => [...n.slice(0, index2), item, ...n.slice(index2)]);
    }
  }
  function remove(item) {
    if (Array.isArray(item)) {
      list.update((n) => n.filter((i) => !item.includes(i)));
    } else {
      list.update((n) => n.filter((i) => i !== item));
    }
  }
  function pop(index2) {
    const _list = unstore(list);
    const item = _list.at(index2 != null ? index2 : -1);
    remove(item != null ? item : []);
    return item;
  }
  function sort2(options = {}) {
    const { type = "string", sortBy, reverse = false } = options;
    const _list = unstore(list);
    if (type === "string") {
      list.set(
        _list.sort(
          (a, b) => reverse ? b.localeCompare(a) : a.localeCompare(b)
        )
      );
    } else if (type === "number") {
      list.set(_list.sort((a, b) => reverse ? b - a : a - b));
    } else if (type === "object") {
      let _sort_by = sortBy != null ? sortBy : Object.keys(_list[0])[0];
      if (reverse) {
        _sort_by = `-${_sort_by}`;
      }
      list.set(sort(_list, _sort_by));
    }
  }
  return {
    subscribe: list.subscribe,
    append,
    clear,
    count: count2,
    copy,
    index,
    insert,
    remove,
    pop,
    sort: sort2
  };
}

// src/lists/fork/index.ts
function fork(list, fn) {
  if (!list)
    return [[], []];
  return list.reduce(
    (acc, item) => {
      const [a, b] = acc;
      if (fn(item)) {
        return [[...a, item], b];
      } else {
        return [a, [...b, item]];
      }
    },
    [[], []]
  );
}

// src/lists/group/index.ts
function group(list, fn) {
  return list.reduce((acc, item) => {
    var _a;
    const id = fn(item);
    const group_list = (_a = acc[id]) != null ? _a : [];
    return __spreadProps(__spreadValues({}, acc), { [id]: [...group_list, item] });
  }, {});
}

// src/lists/intersects/index.ts
function intersects(a, b, options = {}) {
  const { fn = (item) => item } = options;
  if (!a || !b)
    return [false, []];
  const dict_b = b.reduce(
    (acc, item) => __spreadProps(__spreadValues({}, acc), { [fn(item)]: true }),
    {}
  );
  return [
    a.some((item) => dict_b[fn(item)]),
    a.filter((item) => dict_b[fn(item)])
  ];
}

// src/lists/merge/index.ts
function merge(list, other, fn) {
  if (!other && !list)
    return [];
  if (!other)
    return list;
  if (!list)
    return [];
  if (!fn)
    return list;
  const merged = [...list];
  for (const item of other) {
    const matched = merged.find((o) => fn(o) === fn(item));
    if (matched)
      Object.assign(matched, item);
    else
      merged.push(item);
  }
  return merged;
}

// src/lists/select/index.ts
function select(list, fn, condition) {
  return list.reduce((acc, item) => {
    if (condition && !condition(item))
      return acc;
    return [...acc, fn(item)];
  }, []);
}

// src/lists/unique/index.ts
function unique(list, fn) {
  const value_map = list.reduce((acc, item) => {
    const key = fn ? fn(item) : item;
    if (acc[key])
      return acc;
    return __spreadProps(__spreadValues({}, acc), { [key]: item });
  }, {});
  return Object.values(value_map);
}
export {
  cluster,
  count,
  cycle,
  enhance,
  fork,
  group,
  intersects,
  merge,
  select,
  sort,
  unique
};
