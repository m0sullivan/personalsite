import {
  toNumber
} from "./chunk-G47UHES5.js";
import {
  len,
  watchable
} from "./chunk-GC5LEYOY.js";
import {
  browser,
  bypassFilter,
  createFilterWrapper,
  createSingletonPromise,
  debounceFilter,
  isEmpty,
  isEqual,
  isFunction,
  isPartialWritable,
  isReadable,
  isReadableOnly,
  isStore,
  isWritable,
  isWs,
  noop,
  on_destroy,
  pauseableFilter,
  throttleFilter,
  toReadable,
  toWritable,
  type,
  unstore
} from "./chunk-LRJQKUWD.js";
import {
  __spreadValues
} from "./chunk-KLNSLHAC.js";

// src/adjustWithUnit/index.ts
function adjustWithUnit(target, delta) {
  const { subscribe, update } = toWritable(target);
  function update_value(_target, type2) {
    var _a;
    if (typeof _target === "number")
      return type2 === "inc" ? _target + delta : _target - delta;
    const value = ((_a = _target.match(/^-?[0-9]+\.?[0-9]*/)) == null ? void 0 : _a[0]) || "";
    const unit = _target.slice(value.length);
    const result = type2 === "inc" ? parseFloat(value) + delta : parseFloat(value) - delta;
    if (Number.isNaN(result))
      return _target;
    return result + unit;
  }
  return {
    subscribe,
    inc: () => update((n) => update_value(n, "inc")),
    dec: () => update((n) => update_value(n, "dec"))
  };
}

// src/sleep/index.ts
function sleep(s, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), s * 1e3);
    else
      setTimeout(resolve, s * 1e3);
  });
}

// src/asyncState/index.ts
function asyncState(promise, initialState, options = {}) {
  const {
    immediate = true,
    delay = 0,
    onError = noop,
    onSuccess = noop,
    resetOnExecute = true,
    throwError
  } = options != null ? options : {};
  const state = toWritable(initialState);
  const ready = toWritable(false);
  const loading = toWritable(false);
  const error = toWritable(void 0);
  async function execute(delay2 = 0, ...args) {
    if (resetOnExecute)
      state.set(initialState);
    error.set(void 0);
    ready.set(false);
    loading.set(true);
    if (delay2 > 0)
      await sleep(delay2);
    const _promise = typeof promise === "function" ? promise(...args) : promise;
    try {
      const data = await _promise;
      state.set(data);
      ready.set(true);
      onSuccess(data);
    } catch (e) {
      error.set(e);
      onError(e);
      if (throwError)
        throw error;
    } finally {
      loading.set(false);
    }
    return state;
  }
  if (immediate)
    execute(delay);
  return {
    state: toReadable(state),
    ready: toReadable(ready),
    loading: toReadable(loading),
    error: toReadable(error),
    execute
  };
}

// src/createEventHook/index.ts
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  function off(fn) {
    fns.delete(fn);
  }
  function on(fn) {
    fns.add(fn);
    const offFn = () => off(fn);
    on_destroy(offFn);
    return {
      off: offFn
    };
  }
  function trigger(param) {
    return Promise.all(Array.from(fns).map((fn) => fn(param)));
  }
  return {
    on,
    off,
    trigger
  };
}

// src/debounce/index.ts
function debounce(fn, s = 0.2, options = {}) {
  return createFilterWrapper(debounceFilter(s, options), fn);
}

// src/intervalFn/index.ts
import { writable } from "svelte/store";
function intervalFn(fn, interval = 1, options = {}) {
  const { immediate = true, immediateCallback = false } = options;
  const active = writable(false);
  let timer = null;
  function clean() {
    if (timer) {
      clearInterval(timer);
      timer = null;
    }
  }
  function pause() {
    active.set(false);
    clean();
  }
  function resume() {
    if (unstore(interval) <= 0)
      return;
    active.set(true);
    if (immediateCallback)
      fn();
    clean();
    timer = setInterval(fn, unstore(interval) * 1e3);
  }
  if (immediate)
    resume();
  on_destroy(pause);
  return {
    active: toReadable(active),
    pause,
    resume
  };
}

// src/lastChanged/index.ts
function lastChanged(initialValue, initialTimestamp) {
  const timestamp = toWritable(initialTimestamp != null ? initialTimestamp : +Date.now());
  const value = watchable(initialValue, () => timestamp.set(+Date.now()));
  return { value, timestamp: toReadable(timestamp) };
}

// src/makeDestructurable/index.ts
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone = structuredClone(obj);
    Object.defineProperty(clone, Symbol.iterator, {
      enumerable: false,
      value() {
        let index = 0;
        return {
          next: () => ({
            value: arr[index++],
            done: index > arr.length
          })
        };
      }
    });
    return clone;
  } else {
    return Object.assign([...arr], obj);
  }
}

// src/objectUrl/index.ts
function objectUrl(value) {
  let url = "";
  const _value = unstore(value);
  function release() {
    if (url)
      URL.revokeObjectURL(url);
    url = void 0;
  }
  release();
  if (_value)
    url = URL.createObjectURL(_value);
  on_destroy(release);
  return url;
}

// src/range/index.ts
function* range(start, stop, step = 1) {
  if (typeof stop === "undefined") {
    stop = start;
    start = 0;
  }
  if (step > 0 && start >= stop || step < 0 && start <= stop) {
    return [];
  }
  for (let i = start; i <= stop; i += step) {
    yield i;
    if (i + step > stop)
      break;
  }
}

// src/rtf/index.ts
function format(_rtf, time) {
  const delta_seconds = Math.round((time - Date.now()) / 1e3);
  const cutoffs = [
    60,
    3600,
    86400,
    86400 * 7,
    86400 * 30,
    86400 * 365,
    Infinity
  ];
  const units = [
    "second",
    "minute",
    "hour",
    "day",
    "week",
    "month",
    "year"
  ];
  const unit_index = cutoffs.findIndex(
    (cutoff) => cutoff > Math.abs(delta_seconds)
  );
  const divisor = unit_index ? cutoffs[unit_index - 1] : 1;
  return _rtf.format(Math.floor(delta_seconds / divisor), units[unit_index]);
}
function rtf(date, options = {}) {
  const {
    locale = "en",
    style = "long",
    numeric = "auto",
    interval = 60
  } = options;
  const _rtf = new Intl.RelativeTimeFormat(locale, {
    style,
    numeric
  });
  const time = typeof date === "number" ? date : date.getTime();
  const formatted = toWritable(format(_rtf, time));
  intervalFn(() => formatted.set(format(_rtf, time)), interval);
  return toReadable(formatted);
}

// src/slug/index.ts
function slug(options = {}) {
  const { lower = true, upper = true, digits = true } = options;
  let size = options.size || 6;
  let chars = "";
  if (size <= 1)
    size = 2;
  if (lower)
    chars += "abcdefghijklmnopqrstuvwxyz";
  if (upper)
    chars += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  if (digits)
    chars += "0123456789";
  let slug2 = "";
  for (const _ of range(size - 1))
    slug2 += chars[Math.floor(Math.random() * chars.length)];
  return options.prefix ? `${options.prefix}-${slug2}` : slug2;
}

// src/strftime/index.ts
var REGEX_PARSE = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/;
var REGEX_FORMAT = /%S|%Y|%m|%d|%H|%M|%B|%b|%I|%-I|%p|%a|%A|%w|%y|%f|%z|%Z|%j|%U|%W|%c|%x|%X/g;
function format2(date, str, options) {
  const years = date.getFullYear();
  const month = date.getMonth();
  const days = date.getDate();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const milliseconds = date.getMilliseconds();
  const matches = {
    "%a": () => date.toLocaleDateString(options.locales, { weekday: "short" }),
    "%A": () => date.toLocaleDateString(options.locales, { weekday: "long" }),
    "%w": () => String(date.getDay()),
    "%d": () => `${days}`.padStart(2, "0"),
    "%b": () => date.toLocaleDateString(options.locales, { month: "short" }),
    "%B": () => date.toLocaleDateString(options.locales, { month: "long" }),
    "%m": () => `${month + 1}`.padStart(2, "0"),
    "%y": () => `${years}`.slice(-2),
    "%Y": () => `${years}`,
    "%H": () => `${hours}`,
    "%I": () => `${hours % 12 || 12}`.padStart(1, "0"),
    "%-I": () => `${hours % 12 || 12}`.padStart(2, "0"),
    "%p": () => hours < 12 ? "AM" : "PM",
    "%M": () => `${minutes}`.padStart(2, "0"),
    "%S": () => `${seconds}`.padStart(2, "0"),
    "%f": () => `${milliseconds}`.padStart(3, "0"),
    "%z": () => {
      var _a;
      return ((_a = `${date}`.match(/([+-]\d{4})/)) == null ? void 0 : _a[1]) || "";
    },
    "%Z": () => {
      var _a;
      return ((_a = `${date}`.match(/([A-Z]{3,5})/)) == null ? void 0 : _a[1]) || "";
    },
    "%j": () => {
      const start = new Date(years, 0, 0);
      const diff = date.getTime() - start.getTime();
      const day = 1e3 * 60 * 60 * 24;
      return String(Math.floor(diff / day)).padStart(3, "0");
    },
    "%U": () => {
      const start = new Date(years, 0, 0);
      const diff = date.getTime() - start.getTime();
      const one_day = 1e3 * 60 * 60 * 24;
      const day = start.getDay();
      return String(Math.floor((diff / one_day + day) / 7)).padStart(
        2,
        "0"
      );
    },
    "%W": () => {
      const start = new Date(years, 0, 0);
      const diff = date.getTime() - start.getTime();
      const one_day = 1e3 * 60 * 60 * 24;
      const day = start.getDay();
      return String(Math.floor((diff / one_day + day) / 7)).padStart(
        2,
        "0"
      );
    },
    "%c": () => {
      const _options = __spreadValues({}, options);
      delete _options.locales;
      return date.toLocaleString(options.locales, _options);
    }
  };
  function matcher(match) {
    if (!matches[match])
      return match;
    return matches[match]();
  }
  return str.replace(REGEX_FORMAT, matcher);
}
function parser(date) {
  if (date === null)
    return /* @__PURE__ */ new Date(NaN);
  if (date === void 0)
    return /* @__PURE__ */ new Date();
  if (date instanceof Date)
    return new Date(date);
  if (typeof date === "string" && !/Z$/i.test(date)) {
    const d = date.match(REGEX_PARSE);
    if (d) {
      const m = d[2] - 1 || 0;
      const ms = (d[7] || "0").substring(0, 3);
      return new Date(
        d[1],
        m,
        d[3] || 1,
        d[4] || 0,
        d[5] || 0,
        d[6] || 0,
        ms
      );
    }
  }
  return new Date(date);
}
function strftime(date, str, options = {}) {
  return format2(parser(date), str, options);
}

// src/taggable/index.ts
function taggable(value = false) {
  if (isWritable(value)) {
    return (_value) => {
      if (typeof _value !== "undefined") {
        value.set(
          typeof _value === "boolean" ? _value : !unstore(value)
        );
      } else
        value.set(!unstore(value));
    };
  } else {
    const store = toWritable(value);
    const toggle = (_value) => {
      if (typeof _value !== "undefined") {
        store.set(
          typeof _value === "boolean" ? _value : !unstore(store)
        );
      } else
        store.set(!unstore(store));
    };
    return {
      toggled: toReadable(store),
      toggle
    };
  }
}

// src/template/index.ts
function template(str, data, regex = /\{\{(.+?)\}\}/g) {
  return Array.from(str.matchAll(regex)).reduce((acc, match) => {
    const [_, key] = match;
    return acc.replace(match[0], data[key]);
  }, str);
}

// src/throttle/index.ts
function throttle(fn, s = 0.2, trailing = false, leading = true, rejectOnCancel = false) {
  return createFilterWrapper(
    throttleFilter(s, trailing, leading, rejectOnCancel),
    fn
  );
}

// src/timeoutFn/index.ts
import { writable as writable2 } from "svelte/store";
function timeoutFn(fn, interval = 1, options = {}) {
  const { immediate = true, immediateCallback = false } = options;
  const active = writable2(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function pause() {
    active.set(false);
    clear();
  }
  function resume() {
    clear();
    active.set(true);
    if (immediateCallback)
      fn();
    timer = setTimeout(() => {
      active.set(false);
      timer = null;
      fn();
    }, unstore(interval) * 1e3);
  }
  if (immediate)
    resume();
  on_destroy(pause);
  return {
    active: toReadable(active),
    resume,
    pause
  };
}

// src/tryit/index.ts
function atryit(fn) {
  return async (...args) => {
    try {
      return { result: await fn(...args), error: null };
    } catch (err) {
      return { result: null, error: err };
    }
  };
}
function tryit(fn) {
  return (...args) => {
    try {
      return { result: fn(...args), error: null };
    } catch (err) {
      return { result: null, error: err };
    }
  };
}
export {
  adjustWithUnit,
  asyncState,
  atryit,
  browser,
  bypassFilter,
  createEventHook,
  createFilterWrapper,
  createSingletonPromise,
  debounce,
  debounceFilter,
  intervalFn,
  isEmpty,
  isEqual,
  isFunction,
  isPartialWritable,
  isReadable,
  isReadableOnly,
  isStore,
  isWritable,
  isWs,
  lastChanged,
  len,
  makeDestructurable,
  noop,
  objectUrl,
  on_destroy,
  pauseableFilter,
  range,
  rtf,
  sleep,
  slug,
  strftime,
  taggable,
  template,
  throttle,
  throttleFilter,
  timeoutFn,
  toNumber,
  toReadable,
  toWritable,
  tryit,
  type,
  unstore,
  watchable
};
