import { Readable, Writable } from 'svelte/store';

/**
 * Maybe it's a Readable, or a plain value.
 *
 * ```ts
 * type Readable = T | Readable<T>
 * ```
 */
type MaybeReadable<T> = T | Readable<T>;
/**
 * Maybe it's a Writable, or a plain value.
 *
 * ```ts
 * type Writable = T | Writable<T>
 * ```
 */
type MaybeWritable<T> = T | Writable<T>;
/**
 * Maybe it's a Store, or a plain value.
 *
 * ```ts
 * type Store = T | Readable<T> | Writable<T>
 * ```
 */
type MaybeStore<T> = T | Readable<T> | Writable<T>;
/**
 * Infers the element type of an array
 */
type ElementOf<T> = T extends (infer E)[] ? E : never;
/**
 * Void function
 */
type Fn = () => void;
/**
 * Any function
 */
type AnyFn = (...args: any[]) => any;
type Awaitable<T> = Promise<T> | T;
type ListAble<T> = T[] | T;
type ArgumentsType<T> = T extends (...args: infer U) => any ? U : never;
type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
type Dict<T extends string | number | symbol = string | number | symbol, U = any> = Record<T, U>;
type PromisifyFn<T extends AnyFn> = (...args: ArgumentsType<T>) => Promise<ReturnType<T>>;
interface Stoppable<StartFnArgs extends any[] = any[]> {
    /**A an indicate whether a stoppable instance is executing*/
    pending: Readable<boolean>;
    /**Stop the effect from executing*/
    stop: Fn;
    /**Start the effect*/
    start: (...args: StartFnArgs) => void;
}
interface Pauseable {
    /**A an indicate whether a pauseable instance is active*/
    active: Readable<boolean>;
    /**Temporary pause the effect from executing*/
    pause: Fn;
    /**Resume the effects*/
    resume: Fn;
}
interface PartialWritable<T> {
    /**The set function in writable stores. */
    set: (value: T) => void;
    /** The subscribe function in writable stores. */
    subscribe: (run: (value: T) => void, invalidate?: (value?: T) => void) => () => void;
}
type FunctionArgs<Args extends any[] = any[], Return = void> = (...args: Args) => Return;
interface FunctionWrapperOptions<Args extends any[] = any[], This = any> {
    fn: FunctionArgs<Args, This>;
    args: Args;
    thisArg: This;
}
type EventFilter<Args extends any[] = any[], This = any, Invoke extends AnyFn = AnyFn> = (invoke: Invoke, options: FunctionWrapperOptions<Args, This>) => ReturnType<Invoke> | Promise<ReturnType<Invoke>>;
interface ConfigurableEventFilter {
    /**
     * Filter for if events should to be received.
     *
     */
    eventFilter?: EventFilter;
}
interface DebounceFilterOptions {
    /**
     * The maximum time allowed to be delayed before it's invoked.
     * In seconds.
     */
    maxWait?: number;
    /**
     * Whether to reject the last call if it's been cancel.
     *
     * @defaultValue false
     */
    rejectOnCancel?: boolean;
}
interface ToNumberOptions {
    /**
     * Method to use to convert the value to a number.
     *
     * @defaultValue 'float'
     */
    method?: "float" | "int";
    /**
     * The base in mathematical numeral systems passed to `int`.
     * Only works with `method: 'int'`
     */
    radix?: number;
    /**
     * Replace NaN with zero
     *
     * @defaultValue false
     */
    nanToZero?: boolean;
}
interface SlugOptions {
    /**
     * Use lower letters.
     *
     * @defaultValue true
     */
    lower?: boolean;
    /**
     * Use uppercase letters.
     *
     * @defaultValue true
     */
    upper?: boolean;
    /**
     * Use digits.
     *
     * @defaultValue true
     */
    digits?: boolean;
    /**
     * Size of the slug.
     *
     * @defaultValue 6
     */
    size?: number;
    /**
     * Text to use as a prefix.
     *
     */
    prefix?: string;
}
type EventHookOn<T = any> = (fn: (param: T) => void) => {
    off: () => void;
};
type EventHookOff<T = any> = (fn: (param: T) => void) => void;
type EventHookTrigger<T = any> = (param: T) => Promise<unknown[]>;
interface EventHook<T = any> {
    on: EventHookOn<T>;
    off: EventHookOff<T>;
    trigger: EventHookTrigger<T>;
}
interface SingletonPromiseReturn<T> {
    (): Promise<T>;
    /**
     * Reset current staled promise.
     * await it to have proper shutdown.
     */
    reset: () => Promise<void>;
}
interface IntervalFnOptions {
    /**
     * Start the timer immediately
     *
     * @defaultValue true
     */
    immediate?: boolean;
    /**
     * Execute the callback immediate after calling this function
     *
     * @defaultValue false
     */
    immediateCallback?: boolean;
}
interface TimeoutFnOptions {
    /**
     * Start the timer immediate after calling this function
     *
     * @defaultValue true
     */
    immediate?: boolean;
    /**
     * Execute the callback immediate after calling this function
     *
     * @defaultValue false
     */
    immediateCallback?: boolean;
}
interface TimeoutOptions<Controls extends boolean> extends TimeoutFnOptions {
    /**
     * Expose more controls
     *
     * @defaultValue false
     */
    controls?: Controls;
    /**
     * Callback on timeout
     */
    callback?: Fn;
}
type ToggleFn = (value?: boolean) => void;
interface DefaultTaggableReturn {
    toggled: Readable<boolean>;
    toggle: ToggleFn;
}
interface RTFOptions {
    /** The locale to use.
     *
     *
     * @defaultValue en
     */
    locale?: Intl.UnicodeBCP47LocaleIdentifier;
    /** The length of the internationalized message.
     *
     * @defaultValue long
     */
    style?: "long" | "short" | "narrow";
    /** The format of output message.
     *
     * @defaultValue auto
     */
    numeric?: "always" | "auto";
    /**
     * The interval to update the time.
     *
     * @defaultValue 60 second
     */
    interval?: number;
}
type DateLike = Date | number | string | undefined;
interface StrftimeOptions extends Intl.DateTimeFormatOptions {
    /**
     * The locale to use
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#locales_argument
     */
    locales?: Intl.LocalesArgument;
}
type StringOrNumber = string | number;
type Sequential = number[] | string[] | StringOrNumber[] | number[][] | string[][] | StringOrNumber[][];
interface PrecisionOptions {
    /**
     * Method to use for rounding
     *
     * @defaultValue 'round'
     */
    math?: "floor" | "ceil" | "round";
}
interface ClusterOptions {
    /**
     * The size of each list.
     *
     * @defaultValue 2
     */
    size?: number;
}
interface IntersectsOptions<T, K extends string | number | symbol> {
    fn?: (item: T) => K;
}
interface EnhanceSortOptions {
    /**
     * Sorting type
     *
     * @defaultValue string
     */
    type?: "number" | "string" | "object";
    /**
     * If the type is object, this will sort it by the given key
     *
     * @defaultValue if sort_by isn't provided, it will sort by the first key
     
    */
    sortBy?: string;
    /**
     * Reverse the sorting
     *
     * @defaultValue false
     *
     *
     */
    reverse?: boolean;
}
interface AsyncStateOptions<D = any> {
    /**
     * Delay for executing the promise. In second.
     *
     * @defaultValue 0
     */
    delay?: number;
    /**
     * Execute the promise right after the function is invoked.
     * Will apply the delay if any.
     *
     * When set to false, you will need to execute it manually.
     *
     * @defaultValue true
     */
    immediate?: boolean;
    /**
     * Callback when error is caught.
     */
    onError?: (e: unknown) => void;
    /**
     * Callback when success is caught.
     * @param data - The data returned by the promise
     */
    onSuccess?: (data: D) => void;
    /**
     * Sets the state to initial state before executing the promise.
     *
     * This can be useful when calling the execute function more than once (for
     * example, to refresh data). When set to false, the current state remains
     * unchanged until the promise resolves.
     *
     * @defaultValue true
     */
    resetOnExecute?: boolean;
    /**
     *
     * An error is thrown when executing the execute function
     *
     * @defaultValue false
     */
    throwError?: boolean;
}
interface Watchable<T> extends PartialWritable<T> {
    /** Stop watching */
    pause: () => void;
    /** Resume watching */
    resume: () => void;
}
interface CycleOptions<T> {
    /**
     * The initial value of the state.
     * A ref can be provided to reuse.
     */
    fallback?: T;
    /**
     * The default index when
     */
    fallbackIndex?: number;
    /**
     * Custom function to get the index of the current value.
     */
    getIndex?: (value: T, list: T[]) => number;
}

export { AnyFn as A, PrecisionOptions as B, ConfigurableEventFilter as C, DebounceFilterOptions as D, EventFilter as E, Fn as F, ClusterOptions as G, IntersectsOptions as H, IntervalFnOptions as I, EnhanceSortOptions as J, CycleOptions as K, ListAble as L, MaybeStore as M, Pauseable as P, RTFOptions as R, SlugOptions as S, ToggleFn as T, Watchable as W, ArgumentsType as a, AsyncStateOptions as b, EventHook as c, FunctionArgs as d, PromisifyFn as e, DateLike as f, StrftimeOptions as g, DefaultTaggableReturn as h, TimeoutFnOptions as i, ToNumberOptions as j, MaybeReadable as k, MaybeWritable as l, ElementOf as m, Awaitable as n, Mutable as o, Dict as p, Stoppable as q, PartialWritable as r, FunctionWrapperOptions as s, EventHookOn as t, EventHookOff as u, EventHookTrigger as v, SingletonPromiseReturn as w, TimeoutOptions as x, StringOrNumber as y, Sequential as z };
