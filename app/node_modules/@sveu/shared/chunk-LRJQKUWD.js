// src/utils/helpers.ts
import { onDestroy } from "svelte";
import { get, readable, writable } from "svelte/store";

// src/utils/is.ts
var browser = typeof window !== "undefined";
var isWs = typeof WebSocket !== "undefined";
function isFunction(value) {
  return type(value, true) === "[object Function]";
}
function isNumber(value) {
  return type(value, true) === "[object Number]";
}
function isDate(value) {
  return type(value, true) === "[object Date]";
}
function isSymbol(value) {
  return type(value, true) === "[object Symbol]";
}
function isReadable(value) {
  return value && isFunction(value == null ? void 0 : value.subscribe);
}
function isWritable(value) {
  return value && ["subscribe", "set", "update"].every((n) => isFunction(value[n]));
}
function isPartialWritable(value) {
  return value && ["subscribe", "set"].every((n) => isFunction(value[n]));
}
function isReadableOnly(value) {
  return value && isFunction(value == null ? void 0 : value.subscribe) && !isWritable(value) && !isPartialWritable(value);
}
function isStore(value) {
  return isReadable(value) || isWritable(value);
}
function isEmpty(value) {
  if (value === true || value === false)
    return true;
  if (value === null || value === void 0)
    return true;
  if (isNumber(value))
    return value === 0;
  if (isDate(value))
    return isNaN(value.getTime());
  if (isFunction(value))
    return false;
  if (isSymbol(value))
    return false;
  const length = value.length;
  if (isNumber(length))
    return length === 0;
  const size = value.size;
  if (isNumber(size))
    return size === 0;
  const keys = Object.keys(value).length;
  return keys === 0;
}
function isEqual(x, y) {
  if (Object.is(x, y))
    return true;
  if (x instanceof Date && y instanceof Date)
    return x.getTime() === y.getTime();
  if (x instanceof RegExp && y instanceof RegExp)
    return x.toString() === y.toString();
  if (typeof x !== "object" || x === null || typeof y !== "object" || y === null) {
    return false;
  }
  const keysX = Reflect.ownKeys(x);
  const keysY = Reflect.ownKeys(y);
  if (keysX.length !== keysY.length)
    return false;
  for (let i = 0; i < keysX.length; i++) {
    if (!Reflect.has(y, keysX[i]))
      return false;
    if (!isEqual(x[keysX[i]], y[keysX[i]]))
      return false;
  }
  return true;
}
var noop = () => {
};

// src/utils/helpers.ts
function type(value, full = false) {
  const _value = Object.prototype.toString.call(value);
  if (full)
    return _value;
  else
    return _value.slice(8, -1).toLowerCase();
}
function unstore(value) {
  return isReadable(value) ? get(value) : value;
}
function toWritable(value) {
  if (isPartialWritable(value))
    return value;
  if (isReadableOnly(value))
    return writable(unstore(value));
  return writable(value);
}
function toReadable(value) {
  if (isPartialWritable(value)) {
    return {
      subscribe: value.subscribe
    };
  }
  return isReadableOnly(value) ? value : readable(value);
}
function createSingletonPromise(fn) {
  let _promise;
  function wrapper() {
    if (!_promise)
      _promise = fn();
    return _promise;
  }
  wrapper.reset = async () => {
    const _prev = _promise;
    _promise = void 0;
    if (_prev)
      await _prev;
  };
  return wrapper;
}
function on_destroy(fn) {
  try {
    onDestroy(fn);
    return true;
  } catch (e) {
    return false;
  }
}

// src/utils/filters.ts
import { get as get2, writable as writable2 } from "svelte/store";
function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(
        filter(() => fn.apply(this, args), { fn, thisArg: this, args })
      ).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
var bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(s, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop;
  };
  const filter = (invoke) => {
    const duration = s;
    const maxDuration = options.maxWait;
    if (timer)
      _clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      if (maxDuration && duration > maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(invoke());
        }, maxDuration * 1e3);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke());
      }, duration * 1e3);
    });
  };
  return filter;
}
function throttleFilter(s, trailing = true, leading = true, rejectOnCancel = false) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  let lastRejector = noop;
  let lastValue;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
      lastRejector();
      lastRejector = noop;
    }
  };
  const filter = (_invoke) => {
    const duration = s * 1e3;
    const elapsed = Date.now() - lastExec;
    const invoke = () => {
      return lastValue = _invoke();
    };
    clear();
    if (duration <= 0) {
      lastExec = Date.now();
      return invoke();
    }
    if (elapsed > duration && (leading || !isLeading)) {
      lastExec = Date.now();
      invoke();
    } else if (trailing) {
      return new Promise((resolve, reject) => {
        lastRejector = rejectOnCancel ? reject : resolve;
        timer = setTimeout(() => {
          lastExec = Date.now();
          isLeading = true;
          resolve(invoke());
          clear();
        }, duration - elapsed);
      });
    }
    if (!leading && !timer)
      timer = setTimeout(() => isLeading = true, duration);
    isLeading = false;
    return lastValue;
  };
  return filter;
}
function pauseableFilter(extendFilter = bypassFilter) {
  const active = writable2(true);
  function pause() {
    active.set(false);
  }
  function resume() {
    active.set(true);
  }
  const eventFilter = (...args) => {
    if (get2(active))
      extendFilter(...args);
  };
  return { active: toReadable(active), pause, resume, eventFilter };
}

export {
  type,
  unstore,
  toWritable,
  toReadable,
  createSingletonPromise,
  on_destroy,
  browser,
  isWs,
  isFunction,
  isReadable,
  isWritable,
  isPartialWritable,
  isReadableOnly,
  isStore,
  isEmpty,
  isEqual,
  noop,
  createFilterWrapper,
  bypassFilter,
  debounceFilter,
  throttleFilter,
  pauseableFilter
};
